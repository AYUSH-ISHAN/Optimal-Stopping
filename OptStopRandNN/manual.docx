1. run_algo.py

a. FLAGS – use to define only useful flags, Reduces effort of manual argument processing. These flags can be transferred to multiple files in which we import them. Various types of flags are being generated
Can deal with multiple values for same argument stores in list

		For use of flas see prac.py

b. tmp_dirpath and fpath – helps to store the outputs or the results.

2. LSM.py

a. model argument is the Stock Model we are using, in this case it is American BlackScholes

3. LSM.py, regression.py, basis_function.py, backward_induction_pricer.py  -> All these files are interconnected.

All things start from backward_induction_pricer.py

4. backward_induction_pricer.py – In the “stop” function, it goes to LSM.py to calculate “calculate_continuation_value” to get the continuation value in a particular timestep of backward recursion.

5. Only the paths that are In The Money (ITM) are used for the training.

6. np.finfo(float).eps – it is machine’s epsilon. (machines lowest limits for floating type values)

7. Some changes in config.py --> changes Fractional Blackscholes to Blackscholes (already commented in the file)

8. np.linalg.lstsq : Computes vector “x” that approximately solves the equation a@x= b  . In other words return the least-squares solution to a linear matrix equation.




Homework : 

Check the np.linalg.lstq code of Longstaff paper..
See the languere as basis function.

Reproduce Longstaff Paper
Change the polynomial of the continuation value.

Randomly generating 8 X 3 matrices and see tehe output from Longstaff

First sets 8 X 3 for training. Another sets of 8 X 3 for testing.
(testing the LSTM outputs from it)
Training as how they evolve and then measure of loss.

Print the second matrix just below the main matrix in Longstaff. 



Now training and testing :

Let us say we have 8 paths and we go some coefficients after those paths and then we generate th 9th path and check the accuracy like .. 
We are going forward. First took the t=1 and saw by continuation value by fitting the eqaution and comparing the value and then deciding stop or continue. Similar goes for t=2 and t=3. By this see how many predictions were correct by the model and how many of them were correct of the model.
